name: AI Auto-Healing Pipeline

on:
  workflow_run:
    workflows: ["Cypress E2E Tests with Auto-Healing"]
    types: [completed]
    branches: [master, main]

jobs:
  auto-healing:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'failure' }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: master
        
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        
    - name: Download Cypress screenshots (if available)
      uses: actions/download-artifact@v4
      with:
        name: cypress-screenshots
        path: cypress/screenshots
        github-token: ${{ secrets.GITHUB_TOKEN }}
        repository: ${{ github.repository }}
        run-id: ${{ github.event.workflow_run.id }}
        
    - name: Download DOM content (if available)
      uses: actions/download-artifact@v4
      with:
        name: cypress-dom-content
        path: cypress/failures
        github-token: ${{ secrets.GITHUB_TOKEN }}
        repository: ${{ github.repository }}
        run-id: ${{ github.event.workflow_run.id }}
        
    - name: Analyze test failures
      run: |
        echo "üîç Analyzing test failures for auto-healing..."
        echo "Test failure detected in workflow: ${{ github.event.workflow_run.name }}"
        echo "Workflow run ID: ${{ github.event.workflow_run.id }}"
        echo "Failure URL: ${{ github.event.workflow_run.html_url }}"
        
        # Check if artifacts were downloaded
        if [ -d "cypress/screenshots" ] && [ "$(ls -A cypress/screenshots 2>/dev/null)" ]; then
          echo "‚úÖ Screenshots found and downloaded"
          echo "üì∏ Available screenshots:"
          ls -la cypress/screenshots/
        else
          echo "‚ö†Ô∏è No screenshots available for analysis"
        fi
        
        # Check if DOM content was downloaded
        if [ -d "cypress/failures" ] && [ "$(ls -A cypress/failures 2>/dev/null)" ]; then
          echo "‚úÖ DOM content found and downloaded"
          echo "üåê Available DOM files:"
          ls -la cypress/failures/
          echo "üìã Raw files: $(find cypress/failures -name '*.html' ! -name '*-clean.html' | wc -l)"
          echo "üßπ Cleaned files: $(find cypress/failures -name '*-clean.html' | wc -l)"
        else
          echo "‚ö†Ô∏è No DOM content available for analysis"
        fi
        
        # Note: Videos are disabled in cypress.json (video: false)
        echo "‚ÑπÔ∏è Videos are disabled in Cypress configuration"
        
    - name: Build AI Payload
      run: |
        echo "üîß Building AI payload for test failure analysis..."
        
        # Find the cleaned DOM file
        DOM_FILE=$(ls cypress/failures/*-clean.html | head -1)
        if [ ! -f "$DOM_FILE" ]; then
          echo "‚ùå No cleaned DOM file found"
          exit 1
        fi
        
        # Build payload using the dedicated module
        node scripts/ai-payload-builder.js "$DOM_FILE"
        
        # Display full payload
        echo "::group::üì§ OpenAI Request Payload"
        cat openai_payload.json
        echo "::endgroup::"
        
        # Extract test name from DOM file
        TEST_NAME=$(basename "$DOM_FILE" -clean.html 2>/dev/null || echo "Unknown test")
        
        echo "::group::üß™ Test Name"
        echo "$TEST_NAME"
        echo "::endgroup::"
        
        # Show error message if available
        ERROR_LOG_FILE="${DOM_FILE%-clean.html}.log.txt"
        if [ -f "$ERROR_LOG_FILE" ]; then
          echo "::group::‚ùå Error Message"
          cat "$ERROR_LOG_FILE"
          echo "::endgroup::"
        else
          echo "::group::‚ùå Error Message"
          echo "Error log not available"
          echo "::endgroup::"
        fi
        
        echo "::group::üßπ Test HTML Context (Clean)"
        cat "$DOM_FILE"
        echo "::endgroup::"
        
        echo "::group::üìÑ Full Test File"
        cat tests/e2e/new-todo.spec.js
        echo "::endgroup::"
        
        echo "‚úÖ OpenAI API payload prepared"
        
        # Send to OpenAI API
        if [ -n "${{ secrets.OPENAI_API_KEY }}" ]; then
          echo "üîÑ Sending request to OpenAI API..."
          OPENAI_RESPONSE=$(curl -s -X POST https://api.openai.com/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${{ secrets.OPENAI_API_KEY }}" \
            -d @openai_payload.json)
          echo "‚úÖ OpenAI API response received"
          echo "$OPENAI_RESPONSE" > openai_response.json
          
          if echo "$OPENAI_RESPONSE" | jq -e '.choices[0].message.content' > /dev/null 2>&1; then
            OPENAI_ANALYSIS=$(echo "$OPENAI_RESPONSE" | jq -r '.choices[0].message.content')
            
            echo "::group::üìä OpenAI Full Response"
            echo "$OPENAI_RESPONSE" | jq '.'
            echo "::endgroup::"
            
            echo "::group::ü§ñ OpenAI Analysis Response"
            echo "$OPENAI_ANALYSIS"
            echo "::endgroup::"
            
            echo "$OPENAI_ANALYSIS" > openai_analysis.txt
            echo "‚úÖ OpenAI analysis saved for fix application"
          else
            echo "::group::‚ùå OpenAI Response Error"
            echo "$OPENAI_RESPONSE" | jq '.' || echo "$OPENAI_RESPONSE"
            echo "::endgroup::"
          fi
        else
          echo "‚ö†Ô∏è OPENAI_API_KEY not found in secrets"
        fi
        
        echo "üìä Context summary:"
        echo "- Test file: $(cat tests/e2e/new-todo.spec.js | wc -l) lines"
        echo "- DOM content: $(cat "$DOM_FILE" | wc -c) characters"
        echo "- Has screenshots: $([ -d "cypress/screenshots" ] && [ "$(ls -A cypress/screenshots 2>/dev/null)" ] && echo "Yes" || echo "No")"
        echo "- Has DOM content: $([ -d "cypress/failures" ] && [ "$(ls -A cypress/failures 2>/dev/null)" ] && echo "Yes" || echo "No")"
        
    - name: Generate AI-powered fixes
      run: |
        echo "ü§ñ Generating AI-powered fixes based on OpenAI analysis..."
        
        if [ -f "openai_analysis.txt" ]; then
          echo "üìÑ OpenAI analysis found, processing recommendations..."
          
          OPENAI_ANALYSIS=$(cat openai_analysis.txt)
          echo "üîç OpenAI's Analysis:"
          echo "$OPENAI_ANALYSIS"
          
          # Try to parse JSON response
          if echo "$OPENAI_ANALYSIS" | jq -e '.' > /dev/null 2>&1; then
            ANALYSIS=$(echo "$OPENAI_ANALYSIS" | jq -r '.analysis // empty')
            FIX=$(echo "$OPENAI_ANALYSIS" | jq -r '.fix // empty')
            
            echo "üìä Parsed Analysis: $ANALYSIS"
            echo "üîß Recommended Fix: $FIX"
            
            # Save fix for application step
            echo "$FIX" > recommended_fix.txt
            echo "‚úÖ Fix recommendation saved"
            
          else
            echo "üìù Non-JSON response, extracting fix information..."
            # If OpenAI responds in plain text, save it for manual review
            echo "$OPENAI_ANALYSIS" > recommended_fix.txt
            echo "‚úÖ Analysis saved for review"
          fi
          
        else
          echo "‚ö†Ô∏è No OpenAI analysis found, using fallback approach"
          echo "üîÑ Fallback: Basic selector update based on common patterns"
          
          # Create a basic fix suggestion
          echo "Fallback fix: Check for common issues:" > recommended_fix.txt
          echo "1. Text content mismatch (todos vs todo's)" >> recommended_fix.txt
          echo "2. Element not found" >> recommended_fix.txt
          echo "3. Timing issues" >> recommended_fix.txt
          echo "4. Selector changes" >> recommended_fix.txt
        fi
        
        echo "‚úÖ AI-powered fix generation completed"
        
    - name: Create auto-healing branch
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git checkout -b auto-healing/fix-${{ github.run_number }}-${{ github.sha }}
        
    - name: Apply AI-generated fixes
      run: |
        echo "üîß Applying AI-generated fixes..."
        
        if [ -f "openai_analysis.txt" ]; then
          echo "üìÑ AI analysis found, applying fixes..."
          
          # Apply the fix using our code fixer
          node scripts/code-fixer.js openai_analysis.txt
          
          if [ $? -eq 0 ]; then
            echo "‚úÖ Fix applied successfully"
            
            # Read fix info for commit message
            if [ -f "fix-info.json" ]; then
              FIX_INFO=$(cat fix-info.json)
              echo "üìã Fix details:"
              echo "$FIX_INFO"
            fi
            
          else
            echo "‚ùå Fix application failed"
            echo "üìù Creating manual review summary"
            
            echo "AI fix application failed." > fix_summary.txt
            echo "Manual review required." >> fix_summary.txt
            echo "Check openai_analysis.txt for AI recommendations." >> fix_summary.txt
          fi
          
        else
          echo "‚ö†Ô∏è No AI analysis found"
          echo "üìù Creating placeholder fix summary"
          
          echo "No AI analysis available." > fix_summary.txt
          echo "Manual review of test failure required." >> fix_summary.txt
        fi
        
        echo "‚úÖ Fix processing completed"
        
    - name: Commit AI-generated fixes
      run: |
        echo "üìù Committing AI-generated fixes..."
        
        # Check if any files were modified
        if git diff --quiet; then
          echo "‚ö†Ô∏è No changes detected to commit"
        else
          echo "üìã Changes detected, creating commit..."
          
          # Add all changes
          git add .
          
          # Create commit message from fix info
          if [ -f "fix-info.json" ]; then
            FIX_DATA=$(cat fix-info.json)
            FIX_DESC=$(echo "$FIX_DATA" | jq -r '.description // "Auto-healing fix"')
            FIX_FILE=$(echo "$FIX_DATA" | jq -r '.file // "unknown"')
            FIX_LINE=$(echo "$FIX_DATA" | jq -r '.line // "unknown"')
            
            COMMIT_MSG="ü§ñ Auto-heal: $FIX_DESC - File: $FIX_FILE - Line: $FIX_LINE - Type: $(echo "$FIX_DATA" | jq -r '.type // "text_replacement"') - Generated by AI auto-healing pipeline"
          else
            COMMIT_MSG="ü§ñ Auto-heal: Fix test failures - Generated by AI auto-healing pipeline"
          fi
          
          git commit -m "$COMMIT_MSG"
          echo "‚úÖ Changes committed successfully"
        fi
        
    - name: Push auto-healing branch
      run: |
        git push origin auto-healing/fix-${{ github.run_number }}-${{ github.sha }}
        
    - name: Create Pull Request
      uses: peter-evans/create-pull-request@v5
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        title: "ü§ñ Auto-healing: Fix test failures"
        body: |
          ## AI Auto-Healing Fix
          
          This PR contains automated fixes for failing tests detected by the auto-healing pipeline.
          
          **Changes made:**
          - [ ] Updated selectors
          - [ ] Fixed timing issues  
          - [ ] Updated test expectations
          - [ ] Added retry mechanisms
          
          **Test Results:**
          - Original failure: ${{ github.event.workflow_run.html_url }}
          - Auto-healing run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          
          **Next Steps:**
          1. Review the changes
          2. Run tests locally
          3. Merge if tests pass
        branch: auto-healing/fix-${{ github.run_number }}-${{ github.sha }}
        base: master
        delete-branch: true 
